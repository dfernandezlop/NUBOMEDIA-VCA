/* Autogenerated with kurento-module-creator */

#include <gst/gst.h>
#include <vector>
#include <FaceInfo.hpp> 
#include "MediaPipeline.hpp"
#include "MediaPipelineImpl.hpp"
#include <NuboFaceDetectorImplFactory.hpp>
#include "NuboFaceDetectorImpl.hpp"
#include <jsonrpc/JsonSerializer.hpp>
#include <KurentoException.hpp>
#include <SignalHandler.hpp>


#define GST_CAT_DEFAULT kurento_nubo_face_detector_impl
GST_DEBUG_CATEGORY_STATIC (GST_CAT_DEFAULT);
#define GST_DEFAULT_NAME "KurentoNuboFaceDetectorImpl"

#define VIEW_FACES "view-faces"
#define DETECT_BY_EVENT "detect-event"
#define SEND_META_DATA "send-meta-data"
#define FACTOR_SCALE "multi-scale-factor"
#define X_EVERY_4_FRAMES "process-x-every-4-frames"
#define WIDTH_TO_PROCESS "width-to-process"
#define EUCLIDEAN_DISTANCE "euclidean-distance"
#define TRACK_THRESHOLD "track-threshold"
#define AREA_THRESHOLD "area-threshold"
#define ACTIVATE_EVENTS "activate-events"
#define EVENTS_MS "events-ms"

namespace kurento
{
namespace module
{
namespace nubofacedetector
{


void  NuboFaceDetectorImpl::split_message (std::string fi, std::string delimiter, 
					     std::vector<std::string> *v)
{
  size_t pos = 0;
  std::string token;

  while ((pos = fi.find(delimiter)) != std::string::npos) {
    token = fi.substr(0, pos);  
    v->push_back(token);
    fi.erase(0, pos + delimiter.length());
  }

  v->push_back(fi);
  
}

void NuboFaceDetectorImpl::onFace (gchar *message)
{

  /*the String received will be like this ( the ; is the seperation among faces): 
    x:int,y:int,width:int,height:int;x:int,y:int,width:int,height:int;*/
  std::string del1 = ";";
  std::string del2 = ",";
  std::string del3 = ":";
  std::vector<std::string> *faces = new std::vector<std::string>;
  std::vector<std::string> *fields = new std::vector<std::string>;
  std::vector<std::string> *all = new std::vector<std::string>;
  std::vector<std::shared_ptr<FaceInfo>> test;
  int x,y,height,width;
  std::string t;

  bool register_completed=true;
  int i=0;

 
  try {
    
    split_message(message,del1,faces);
    for( i=0; (int)(faces->size())>i; i++) 
      split_message(faces->at(i),del2,fields);
    
    for( i=0; (int)(fields->size())>i; i++)
      split_message(fields->at(i),del3,all);
    
    FaceInfo *fi;
    
    for(int i=0; (int)(all->size())>i; i=i+2)
      {
	
	if (register_completed)
	  {
	    t="face";
	    x=0;y=0;width=0;height=0;
	    register_completed=false;
	  }
	if (0==all->at(i).compare("x")) 	
	  {
	    if ((i+1)< (int)(all->size()))	      
	      x=std::stoi(all->at(i+1));
	  }
	else if (0==all->at(i).compare("y")) 
	  {
	    if ((i+1)< (int)(all->size()))
	      y=std::stoi(all->at(i+1));
	  }
	
	else if (0==all->at(i).compare("width"))     
	  {
	    if ((i+1)< (int)(all->size()))
	      width=std::stoi(all->at(i+1));
	  }
	else if (0==all->at(i).compare("height"))     
	  {
	    if ((i+1)< (int)(all->size()))
	      {
		height=std::stoi(all->at(i+1));
		std::shared_ptr <FaceInfo> cand ( new FaceInfo(t,x,y,width,height));
		test.push_back(cand);
		register_completed=true;
	      }
	  }
      }
   
    if (test.size()>0)
      {
	OnFace event (shared_from_this(), OnFace::getName(), test);
	signalOnFace (event);
      }
  } catch (std::bad_weak_ptr &e) {
  }
}

void NuboFaceDetectorImpl::postConstructor ()
{
handlerOnFaceEvent = register_signal_handler (G_OBJECT (nubo_face),
		        "face-event",
			 std::function <void (GstElement *, gchar *) >
			 (std::bind (&NuboFaceDetectorImpl::onFace, this,
                         std::placeholders::_2) ),
                          std::dynamic_pointer_cast<NuboFaceDetectorImpl>
		          (shared_from_this() ) );
}

NuboFaceDetectorImpl::NuboFaceDetectorImpl (const boost::property_tree::ptree &config, std::shared_ptr<MediaPipeline> mediaPipeline)  : FilterImpl (config, 
          std::dynamic_pointer_cast<MediaPipelineImpl> (mediaPipeline) )
{
  g_object_set (element, "filter-factory", "nubofacedetector", NULL);
  g_object_get (G_OBJECT (element), "filter", &nubo_face, NULL);
  
  if (NULL == nubo_face) {
    throw KurentoException (MEDIA_OBJECT_NOT_AVAILABLE,
                            "Media Object not available");
  }
  
  handlerOnFaceEvent = 0;
  //bus_handler_id = 0;
  g_object_unref (nubo_face);
}

void NuboFaceDetectorImpl::showFaces (int viewFaces)
{
  g_object_set (G_OBJECT (nubo_face), VIEW_FACES, viewFaces, NULL);
}

void NuboFaceDetectorImpl::detectByEvent (int event)
{
  g_object_set (G_OBJECT (nubo_face), DETECT_BY_EVENT, event, NULL);

}

void NuboFaceDetectorImpl::sendMetaData (int metaData)
{
  g_object_set (G_OBJECT (nubo_face), SEND_META_DATA , metaData, NULL);
}

void NuboFaceDetectorImpl::multiScaleFactor (int scaleFactor)
{
  g_object_set (G_OBJECT (nubo_face), FACTOR_SCALE , scaleFactor, NULL);
}

void NuboFaceDetectorImpl::processXevery4Frames (int xper4)
{
  g_object_set (G_OBJECT (nubo_face), X_EVERY_4_FRAMES , xper4, NULL);
}

void NuboFaceDetectorImpl::widthToProcess (int width)
{

  g_object_set (G_OBJECT (nubo_face), WIDTH_TO_PROCESS , width, NULL);
}

void NuboFaceDetectorImpl::euclideanDistance (int distance)
{
  g_object_set (G_OBJECT (nubo_face), EUCLIDEAN_DISTANCE , distance, NULL);
}

void NuboFaceDetectorImpl::trackThreshold (int threshold)
{
  g_object_set (G_OBJECT (nubo_face), TRACK_THRESHOLD , threshold, NULL);
}

void NuboFaceDetectorImpl::areaThreshold (int threshold)
{
  g_object_set (G_OBJECT (nubo_face), AREA_THRESHOLD , threshold, NULL);
}

  void NuboFaceDetectorImpl::activateServerEvents (int activate,int ms)
{
  g_object_set (G_OBJECT (nubo_face), ACTIVATE_EVENTS , activate, NULL);
  g_object_set (G_OBJECT (nubo_face), EVENTS_MS , ms , NULL);
}

void NuboFaceDetectorImpl::unsetOverlayedImage ()
{
  GstStructure *imageSt;
  imageSt = gst_structure_new ("image",
                               "offsetXPercent", G_TYPE_DOUBLE, 0.0,
                               "offsetYPercent", G_TYPE_DOUBLE, 0.0,
                               "widthPercent", G_TYPE_DOUBLE, 0.0,
                               "heightPercent", G_TYPE_DOUBLE, 0.0,
                               "url", G_TYPE_STRING, NULL,
                               NULL);
  g_object_set (G_OBJECT (nubo_face), "image-to-overlay", imageSt, NULL);
  gst_structure_free (imageSt);
}

void NuboFaceDetectorImpl::setOverlayedImage (const std::string &uri, float offsetXPercent, float offsetYPercent, float widthPercent, float heightPercent)
{
  GstStructure *imageSt;
  imageSt = gst_structure_new ("image",
                               "offsetXPercent", G_TYPE_DOUBLE, double (offsetXPercent),
                               "offsetYPercent", G_TYPE_DOUBLE, double (offsetYPercent),
                               "widthPercent", G_TYPE_DOUBLE, double (widthPercent),
                               "heightPercent", G_TYPE_DOUBLE, double (heightPercent),
                               "url", G_TYPE_STRING, uri.c_str(),
                               NULL);
  g_object_set (G_OBJECT (nubo_face), "image-to-overlay", imageSt, NULL);
  gst_structure_free (imageSt);
}

MediaObjectImpl *
NuboFaceDetectorImplFactory::createObject (const boost::property_tree::ptree &config, std::shared_ptr<MediaPipeline> mediaPipeline) const
{
  return new NuboFaceDetectorImpl (config, mediaPipeline);
}

NuboFaceDetectorImpl::StaticConstructor NuboFaceDetectorImpl::staticConstructor;

NuboFaceDetectorImpl::StaticConstructor::StaticConstructor()
{
  GST_DEBUG_CATEGORY_INIT (GST_CAT_DEFAULT, GST_DEFAULT_NAME, 0,
                           GST_DEFAULT_NAME);
}

NuboFaceDetectorImpl::~NuboFaceDetectorImpl()
{
  if ( handlerOnFaceEvent > 0) {
    unregister_signal_handler (nubo_face, handlerOnFaceEvent );
  }
}
} /* nubofacedetector */
} /* module */
} /* kurento */
